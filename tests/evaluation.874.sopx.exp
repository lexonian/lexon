/** Lexon-generated Sophia code
 **
 **	code:        Evaluation License System
 **
 **	preamble:    This is licensing contract for software evaluation
 **
 **	authors:     FLORIAN IDELBERGER, HENNING DIEDRICH
 **
 **	file:        lexon/evaluation.874.lex
 **
 **	code tagged: 0.2.1
 **
 **	compiler:    lexon 0.3 alpha 97 U
 **
 **	grammar:     0.2.20 / subset 0.3.8.2 alpha 97 - English / Reyes
 **
 **	backend:     sophia 0.3.97g U
 **
 **	target:      sophia 7.1+
 **
 **	options:     --sophia  --all-auxiliaries 
 **


   INSTRUCTIONS FOR USE:

   Deploy this smart contract to the Aeternity blockchain or testchain. An easy way to
   get started is to copy-paste this code into  https://studio.aepps.com.  Replace the
   <parameters> with literal values to interact with the contract via terminal.

   LIKE ALL SMART CONTRACTS THIS CODE MUST BE AUDITED BEFORE USING IT IN PRODUCTION.

   Note  that the instructions below  reflect your Lexon code,  as well as the options
   used during compilation of the code: different clauses and options will result from
   different input code.  Some functions are 'built-in' but only appear when needed as
   per compiler options used  during compilation – a list of options is available with
   lexon -h.  The functions are given in the order of appearance, in the Lexon source.

   The required caller is noted in double angle brackets << >>.  Some functions can be
   called by anyone.  Note that roles are being defined by using an account for it for
   the first time. This will require for the same account to be used for the same role
   after this point. Else, the call will revert, i.e. cancelled and not go through.

   Some clauses of the original Lexon source text do not appear in the comments below.
   Namely, those without permission phrase, wherefore they are regarded as internal.

   These are the constructor parameters for deployment. If you are using Aestudio, the
   fields under the deploy button are where your values for them go before deploying.

   <agent : option(address)>, <licensing_fee : option(int)>, <breach_fee : option(int)>

   These are the state progress functions that allow to interact with the contract:


   The following are actions that can be performed per License.

   > license = evaluation.add_license(<licensee : option(address)>, <description_of_goods : option(string)>)
   • <<Licensee>> ⟶   pay()
   • <<Licensor>> ⟶   commission()
   • <<Licensee>> ⟶   comment(<comment_text : option(string)>)
   • <<Licensee>> ⟶   publication()
   • <<Licensee>> ⟶   grant_permission_to_comment()
   • <<Agent>> ⟶   declare_breach()
   • anyone ⟶   factually_breached()
   • <<Agent or Licensor>> ⟶   notice()
   • anyone ⟶   noticed()
 */

@compiler >=6

include "Option.aes"

/**
 **
 **	Main Evaluation License System contract system
 **
 **/

/*
 | 	LEX: Evaluation License System
 | 
 | 	LEXON: 0.2.1
 | 	AUTHORS: FLORIAN IDELBERGER, HENNING DIEDRICH
 | 	PREAMBLE: This is licensing contract for software evaluation
 | 
 | 	
 | 	TERMS:
 | 
 | 	"Licensor" is person
 | 
 | 	"Agent" is person
 | 
 | 	"Licensing Fee" is amount
 | 
 | 	"Breach Fee" is amount
 | 
 | 	
 | 	The Licensor appoints the Agent,
 | 	fixes the Licensing Fee,
 | 	and fixes the Breach Fee
 */



main contract EvaluationLicenseSystem =

    record state = {
            licensor : option(address),
            agent : option(address),
            licensing_fee : option(int),
            breach_fee : option(int)
        }

    entrypoint init(agent : address, licensing_fee : int, breach_fee : int) = {
            licensor = Some(Call.caller),
            agent = Some(agent),
            licensing_fee = Some(licensing_fee),
            breach_fee = Some(breach_fee)
        }


    /* built-in safe transfer */

    stateful function transfer(to : address, amount : int) =
        Chain.spend(to, amount)

    /* built-in caller assertion */

    function permit(authorized : option(address), name : string) =
        require(Call.caller == force(authorized, name), StringInternal.concat("no access for ", name))

    /* built-in option type force function */

    function force(o : option('a), name : string) : 'a =
        switch(o)
            None => abort(StringInternal.concat(name, " not fixed"))
            Some(a) => a

/* aggregation of covenants for folds and serialization */

this._license_list = {};
this._license_count = 0;

/**
 **
 **	License covenant class
 **
 **/

/*
 | 	TERMS PER License
 | 
 | 	"Description of Goods" is text
 | 
 | 	"Licensee" is person
 | 
 | 	"Paid" is binary
 | 
 | 	"Commissioned" is binary
 | 
 | 	"Comment Text" is text
 | 
 | 	"Published" is binary
 | 
 | 	"Permission to Comment" is binary
 | 
 | 	"Notice Time" is time
 | 
 | 	"License" is this contract
 | 
 | 	
 | 	The Licensor appoints the Licensee, and fixes the Description of Goods
 */

contract License =

    record state = {
        description_of_goods : option(string),
        licensee : option(address),
        paid : option(bool),
        commissioned : option(bool),
        comment_text : option(string),
        published : option(bool),
        permission_to_comment : option(bool),
        notice_time : option(int)
        }

    entrypoint init(licensee : address, description_of_goods : string) = {
        description_of_goods = Some(description_of_goods),
        licensee = Some(licensee),
        paid = None,
        commissioned = None,
        comment_text = None,
        published = None,
        permission_to_comment = None,
        notice_time = None
        }


    /* Pay clause */

    /*
     |  CLAUSE: Pay
     |  
     |  The Licensee pays the Licensing Fee to the Licensor,
     |  and pays the Breach Fee into escrow
     |  
     |  This License is therefore Paid
     */

    stateful entrypoint pay() =
        check_termination()
        require(Some(Call.caller) == licensee, "not permitted")
        if(Some(Call.caller) == licensee)
            transfer(force(state.licensor, "Licensor"), force(state.licensing_fee, "Licensing Fee"))
        paid = true;


    /* Commission clause */

    /*
     |  CLAUSE: Commission
     |  
     |  The Licensor may certify this License as Commissioned
     */

    stateful entrypoint commission() =
        check_termination()
        permit(state.licensor, "Licensor")
        put(state{commissioned = true})


    /* Comment clause */

    /*
     |  CLAUSE: Comment
     |  
     |  The Licensee may register Comment Text.
     */

    stateful entrypoint comment(comment_text : string) =
        check_termination()
        permit(licensee, "Licensee")
        put(state{comment_text = Some(comment_text)})


    /* Publication clause */

    /*
     |  CLAUSE: Publication
     |  
     |  The Licensee may certify this License as Published
     */

    stateful entrypoint publication() =
        check_termination()
        permit(licensee, "Licensee")
        put(state{published = true})


    /* Grant Permission to Comment clause */

    /*
     |  CLAUSE: Grant Permission to Comment
     |  
     |  The Licensee may grant the Permission to Comment
     */

    stateful entrypoint grant_permission_to_comment() =
        check_termination()
        permit(licensee, "Licensee")
        put(state{permission_to_comment = true})


    /* Declare Breach clause */

    /*
     |  CLAUSE: Declare Breach
     |  
     |  The Agent may, provided this License is Factually Breached:
     |  pay the Breach Fee to the Licensor,
     |  and afterwards terminate this License
     */

    stateful entrypoint declare_breach() =
        check_termination()
        permit(state.agent, "Agent")
        if(factually_breached() == Some(true))
            transfer(force(state.licensor, "Licensor"), force(state.breach_fee, "Breach Fee"))
            termination()


    /* Factually Breached clause */

    /*
     |  CLAUSE: Factually Breached
     |  
     |  "Factually Breached" is defined as:
     |  this License is Commissioned and the Comment Text is not fixed,
     |  or this License is Published and there is no Permission to Comment and the Notice Time lies at least 24 hours in the past
     */

    entrypoint factually_breached() =
        ((commissioned == Some(true) && comment_text == None)
                 || (published == Some(true) && (permission_to_comment == Some(false) && (notice_time =< (Chain.timestamp - (24 * 3600000))))))


    /* Notice clause */

    /*
     |  CLAUSE: Notice
     |  
     |  The Licensor or the Agent may fix the Notice Time as the respective current time
     */

    stateful entrypoint notice() =
        check_termination()
        require(Some(Call.caller) == state.agent || Some(Call.caller) == state.licensor, "not permitted")
        put(state{notice_time = Chain.timestamp})


    /* Noticed clause */

    /*
     |  CLAUSE: Noticed
     |  
     |  "Noticed" is defined as Notice Time being fixed
     */

    entrypoint noticed() =
        notice_time != None


    /* built-in termination of this covenant */

    stateful function termination() =
        put(state{terminated = true})

    function already_terminated() =
            state.terminated

/* end */
